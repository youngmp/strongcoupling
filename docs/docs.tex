% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
\PassOptionsToPackage{dvipsnames,svgnames*,x11names*}{xcolor}
%
\documentclass[
  english,
  a4paper,
  oneside]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\hypersetup{
  pdfauthor={Youngmin Park},
  pdflang={en},
  colorlinks=true,
  linkcolor=blue,
  filecolor=Maroon,
  citecolor=Blue,
  urlcolor=Blue,
  pdfcreator={LaTeX via pandoc}}
\urlstyle{same} % disable monospaced font for URLs
\usepackage[margin=1in]{geometry}
\usepackage{longtable,booktabs}
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
% Make links footnotes instead of hotlinks:
\DeclareRobustCommand{\href}[2]{#2\footnote{\url{#1}}}
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{-\maxdimen} % remove section numbering
\ifxetex
  % Load polyglossia as late as possible: uses bidi with RTL langages (e.g. Hebrew, Arabic)
  \usepackage{polyglossia}
  \setmainlanguage[]{english}
\else
  \usepackage[shorthands=off,main=english]{babel}
\fi

\title{High-Order Accuracy Coumputation of Coupling Functions for Strongly
Coupled Oscllators (Documentation)}
\author{Youngmin Park}
\date{}

\begin{document}
\maketitle

{
\hypersetup{linkcolor=}
\setcounter{tocdepth}{4}
\tableofcontents
}
\hypertarget{introduction}{%
\section{Introduction}\label{introduction}}

StrongCoupling is a script for computing the higher-order coupling
functions in my paper with Dan Wilson, ``High-Order Accuracy Compuation
of Coupling Functions for Strongly Coupled Oscillators''

\hypertarget{dependencies}{%
\subsection{Dependencies}\label{dependencies}}

\begin{longtable}[]{@{}lll@{}}
\toprule
Package & Version & Link\tabularnewline
\midrule
\endhead
Python & 3.7.7 &\tabularnewline
Matplotlib & 3.3.1 &\tabularnewline
Numpy & 1.19.1 &\tabularnewline
Scipy & 1.5.2 &\tabularnewline
Pathos & 0.2.6 & https://anaconda.org/conda-forge/pathos\tabularnewline
tqdm & 4.48.2 & https://anaconda.org/conda-forge/tqdm\tabularnewline
Sympy & 1.6.2 & https://anaconda.org/anaconda/sympy\tabularnewline
\bottomrule
\end{longtable}

Notes on depedendencies:

Python 3.7+ is necessary. Our code often requires more than 256 function
inputs. Python 3.6 or earlier versions have a limit of 256 inputs and
will not work with our scripts.

The script will likely work with earlier versions of all other
libraries.

pathos is necessary for parallel computing and because pickling is more
robust. I use lots of sympy objects that the multiprocessing library
often can not pickle. In contrast, pathos uses dill, which can often
pickle objects that the pickle module can not.

tqdm provides a status bar for parallel computing. It is not part of the
engine, and the code can be modified to work without it. In future
versions I may leave tqdm as a toggle.

\hypertarget{installation}{%
\subsection{Installation}\label{installation}}

I will not release this script as an installable package simply because
I do not have to time to maintain regular version releases for
distribution platforms such as anaconda, pip, and apt. As long as your
computer has the packages listed above and they are installed using
Python 3.7, the script should run. Worst case scenario, yarrr matey a
Windows 10 virutal machine and install everything using anaconda.

Note that in Ubuntu you may need to set up a virtual environment to be
able to run the script. The system uses Python 3.6 by default and does
not like it when the default is changed to Python 3.7.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\hypertarget{StrongCoupling}{%
\section{\texorpdfstring{Module
\texttt{StrongCoupling}}{Module StrongCoupling}}\label{StrongCoupling}}

@author: Youngmin Park

The logical flow of the class follows the paper by Wilson 2020. -produce
heterogeneous terms for g for arbirary dx -substitute dx with g=g0 +
psi\emph{g1 + psi\^{}2}g2+\ldots{} -produce het. terms for irc -

this file is also practice for creating a more general class for any
RHS.

coupling functions for thalamic neurons from RTSA Ermentrout, Park,
Wilson 2019

Notes -----= -PA requires endpoint=False. make sure corresponding dxAs
are used.

TODO: add backwards as an option for i,g,z.

\hypertarget{functions}{%
\subsection{Functions}\label{functions}}

\hypertarget{StrongCoupling.module_exists}{%
\subsubsection{\texorpdfstring{Function
\texttt{module\_exists}}{Function module\_exists}}\label{StrongCoupling.module_exists}}

\begin{quote}
\begin{verbatim}
def module_exists(
    module_name
)
\end{verbatim}
\end{quote}

\hypertarget{classes}{%
\subsection{Classes}\label{classes}}

\hypertarget{StrongCoupling.StrongCoupling}{%
\subsubsection{\texorpdfstring{Class
\texttt{StrongCoupling}}{Class StrongCoupling}}\label{StrongCoupling.StrongCoupling}}

\begin{quote}
\begin{verbatim}
class StrongCoupling(
    rhs,
    coupling,
    LC_init,
    var_names,
    pardict,
    **kwargs
)
\end{verbatim}
\end{quote}

Thalamic model from RSTA 2019 Requires sympy, numpy, matplotlib.

See the defaults dict below for allowed kwargs.

All model parameters must follow the convention `parameter\_val'. No
other underscores should be used. the script splits the parameter name
at '\_' and uses the string to the left as the sympy parmeter name.

Reserved names: \ldots{}

g\_forward: list or bool. If bool, integrate forwards or backwards when
computing g\^{}k. If list, integrate g\^{}k forwards or backwards based
on bool value g\_forward{[}k{]} z\_forward: list or bool. Same idea as
g\_forward for PRCS i\_forward: list or bool. Same idea as g\_forward
for IRCS

g\_bad\_dx: list or bool. If bool, use another variable to increase the
magnitude of the Newton derivative. This can only be determined after
attempting to run simulations and seeing that the Jacobian for the
Newton step is ill-conditioned. If list, check for ill-conditioning for
each order k. For example, we use g\_small\_dx =
{[}False,True,False,\ldots,False{]} for the thalamic model. The CGL
model only needs g\_small\_idx = False z\_bad\_idx: same idea as
g\_small\_idx for PRCs i\_bad\_idx: same idea as g\_small\_idx for IRCs

coupling\_pars: str. example: input '\_d='+str(d\_par) to include the d
parameter d\_par in the hodd function name.

\hypertarget{methods}{%
\paragraph{Methods}\label{methods}}

\hypertarget{StrongCoupling.StrongCoupling.bispeu}{%
\subparagraph{\texorpdfstring{Method
\texttt{bispeu}}{Method bispeu}}\label{StrongCoupling.StrongCoupling.bispeu}}

\begin{quote}
\begin{verbatim}
def bispeu(
    self,
    fn,
    x,
    y
)
\end{verbatim}
\end{quote}

silly workaround \url{https://stackoverflow.com/questions/47087109/...}
evaluate-the-output-from-scipy-2d-interpolation-along-a-curve

\hypertarget{StrongCoupling.StrongCoupling.dg}{%
\subparagraph{\texorpdfstring{Method
\texttt{dg}}{Method dg}}\label{StrongCoupling.StrongCoupling.dg}}

\begin{quote}
\begin{verbatim}
def dg(
    self,
    t,
    z,
    order,
    het_vec
)
\end{verbatim}
\end{quote}

g functon rhs with ith het. term

z: position t: time jacLC: jacobian on LC het: heterogeneous terms

order determines the Taylor expansion term

\hypertarget{StrongCoupling.StrongCoupling.di}{%
\subparagraph{\texorpdfstring{Method
\texttt{di}}{Method di}}\label{StrongCoupling.StrongCoupling.di}}

\begin{quote}
\begin{verbatim}
def di(
    self,
    t,
    z,
    order,
    het_vec
)
\end{verbatim}
\end{quote}

g functon rhs with ith het. term

z: position t: time jacLC: jacobian on LC het: heterogeneous terms

order determines the Taylor expansion term

\hypertarget{StrongCoupling.StrongCoupling.dz}{%
\subparagraph{\texorpdfstring{Method
\texttt{dz}}{Method dz}}\label{StrongCoupling.StrongCoupling.dz}}

\begin{quote}
\begin{verbatim}
def dz(
    self,
    t,
    z,
    order,
    het_vec
)
\end{verbatim}
\end{quote}

g functon rhs with ith het. term

z: position t: time jacLC: jacobian on LC het: heterogeneous terms

order determines the Taylor expansion term

\hypertarget{StrongCoupling.StrongCoupling.fLam2}{%
\subparagraph{\texorpdfstring{Method
\texttt{fLam2}}{Method fLam2}}\label{StrongCoupling.StrongCoupling.fLam2}}

\begin{quote}
\begin{verbatim}
def fLam2(
    self,
    fn
)
\end{verbatim}
\end{quote}

interp2db object

\hypertarget{StrongCoupling.StrongCoupling.fmod}{%
\subparagraph{\texorpdfstring{Method
\texttt{fmod}}{Method fmod}}\label{StrongCoupling.StrongCoupling.fmod}}

\begin{quote}
\begin{verbatim}
def fmod(
    self,
    fn
)
\end{verbatim}
\end{quote}

fn has mod built-in

input function-like. usually interp1d object

needed to keep lambda input variable unique to fn.

otherwise lambda will use the same input variable for all lambda
functions.

\hypertarget{StrongCoupling.StrongCoupling.generate_expansions}{%
\subparagraph{\texorpdfstring{Method
\texttt{generate\_expansions}}{Method generate\_expansions}}\label{StrongCoupling.StrongCoupling.generate_expansions}}

\begin{quote}
\begin{verbatim}
def generate_expansions(
    self
)
\end{verbatim}
\end{quote}

generate expansions from Wilson 2020

\hypertarget{StrongCoupling.StrongCoupling.generate_g}{%
\subparagraph{\texorpdfstring{Method
\texttt{generate\_g}}{Method generate\_g}}\label{StrongCoupling.StrongCoupling.generate_g}}

\begin{quote}
\begin{verbatim}
def generate_g(
    self,
    k,
    het_vec
)
\end{verbatim}
\end{quote}

generate Floquet eigenfunctions g

uses Newtons method

\hypertarget{StrongCoupling.StrongCoupling.generate_h_odd}{%
\subparagraph{\texorpdfstring{Method
\texttt{generate\_h\_odd}}{Method generate\_h\_odd}}\label{StrongCoupling.StrongCoupling.generate_h_odd}}

\begin{quote}
\begin{verbatim}
def generate_h_odd(
    self,
    k
)
\end{verbatim}
\end{quote}

interaction functions

note to self: see nb page 130 for notes on indexing in sums. need to sum
over to index N-1 out of size N to avoid double counting boundaries in
mod operator.

\hypertarget{StrongCoupling.StrongCoupling.generate_het_sym}{%
\subparagraph{\texorpdfstring{Method
\texttt{generate\_het\_sym}}{Method generate\_het\_sym}}\label{StrongCoupling.StrongCoupling.generate_het_sym}}

\begin{quote}
\begin{verbatim}
def generate_het_sym(
    self
)
\end{verbatim}
\end{quote}

Generate heterogeneous terms for integrating the Z\_i and I\_i terms.

Returns

None.

\hypertarget{StrongCoupling.StrongCoupling.generate_i}{%
\subparagraph{\texorpdfstring{Method
\texttt{generate\_i}}{Method generate\_i}}\label{StrongCoupling.StrongCoupling.generate_i}}

\begin{quote}
\begin{verbatim}
def generate_i(
    self,
    k,
    het_vec
)
\end{verbatim}
\end{quote}

i0 equation is stable in forwards time i1, i2, etc equations are stable
in backwards time.

\hypertarget{StrongCoupling.StrongCoupling.generate_k_sym}{%
\subparagraph{\texorpdfstring{Method
\texttt{generate\_k\_sym}}{Method generate\_k\_sym}}\label{StrongCoupling.StrongCoupling.generate_k_sym}}

\begin{quote}
\begin{verbatim}
def generate_k_sym(
    self
)
\end{verbatim}
\end{quote}

\hypertarget{StrongCoupling.StrongCoupling.generate_limit_cycle}{%
\subparagraph{\texorpdfstring{Method
\texttt{generate\_limit\_cycle}}{Method generate\_limit\_cycle}}\label{StrongCoupling.StrongCoupling.generate_limit_cycle}}

\begin{quote}
\begin{verbatim}
def generate_limit_cycle(
    self
)
\end{verbatim}
\end{quote}

\hypertarget{StrongCoupling.StrongCoupling.generate_p}{%
\subparagraph{\texorpdfstring{Method
\texttt{generate\_p}}{Method generate\_p}}\label{StrongCoupling.StrongCoupling.generate_p}}

\begin{quote}
\begin{verbatim}
def generate_p(
    self,
    k
)
\end{verbatim}
\end{quote}

\hypertarget{StrongCoupling.StrongCoupling.generate_p_old}{%
\subparagraph{\texorpdfstring{Method
\texttt{generate\_p\_old}}{Method generate\_p\_old}}\label{StrongCoupling.StrongCoupling.generate_p_old}}

\begin{quote}
\begin{verbatim}
def generate_p_old(
    self,
    k
)
\end{verbatim}
\end{quote}

\hypertarget{StrongCoupling.StrongCoupling.generate_z}{%
\subparagraph{\texorpdfstring{Method
\texttt{generate\_z}}{Method generate\_z}}\label{StrongCoupling.StrongCoupling.generate_z}}

\begin{quote}
\begin{verbatim}
def generate_z(
    self,
    k,
    het_vec
)
\end{verbatim}
\end{quote}

\hypertarget{StrongCoupling.StrongCoupling.interp_lam}{%
\subparagraph{\texorpdfstring{Method
\texttt{interp\_lam}}{Method interp\_lam}}\label{StrongCoupling.StrongCoupling.interp_lam}}

\begin{quote}
\begin{verbatim}
def interp_lam(
    self,
    k,
    fn_dict,
    fn_type='z'
)
\end{verbatim}
\end{quote}

it is too slow to call individual interpolated functions in the symbolic
heterogeneous terms. soince the heterogeneous terms only depend on t,
just make and interpolated version and use that instead so only 1
function is called for the het. terms per iteration in numerical
iteration.

\hypertarget{StrongCoupling.StrongCoupling.load_g}{%
\subparagraph{\texorpdfstring{Method
\texttt{load\_g}}{Method load\_g}}\label{StrongCoupling.StrongCoupling.load_g}}

\begin{quote}
\begin{verbatim}
def load_g(
    self
)
\end{verbatim}
\end{quote}

load all Floquet eigenfunctions g or recompute

\hypertarget{StrongCoupling.StrongCoupling.load_g_sym}{%
\subparagraph{\texorpdfstring{Method
\texttt{load\_g\_sym}}{Method load\_g\_sym}}\label{StrongCoupling.StrongCoupling.load_g_sym}}

\begin{quote}
\begin{verbatim}
def load_g_sym(
    self
)
\end{verbatim}
\end{quote}

\hypertarget{StrongCoupling.StrongCoupling.load_h}{%
\subparagraph{\texorpdfstring{Method
\texttt{load\_h}}{Method load\_h}}\label{StrongCoupling.StrongCoupling.load_h}}

\begin{quote}
\begin{verbatim}
def load_h(
    self
)
\end{verbatim}
\end{quote}

\hypertarget{StrongCoupling.StrongCoupling.load_h_sym}{%
\subparagraph{\texorpdfstring{Method
\texttt{load\_h\_sym}}{Method load\_h\_sym}}\label{StrongCoupling.StrongCoupling.load_h_sym}}

\begin{quote}
\begin{verbatim}
def load_h_sym(
    self
)
\end{verbatim}
\end{quote}

also compute h lam

\hypertarget{StrongCoupling.StrongCoupling.load_het_sym}{%
\subparagraph{\texorpdfstring{Method
\texttt{load\_het\_sym}}{Method load\_het\_sym}}\label{StrongCoupling.StrongCoupling.load_het_sym}}

\begin{quote}
\begin{verbatim}
def load_het_sym(
    self
)
\end{verbatim}
\end{quote}

\hypertarget{StrongCoupling.StrongCoupling.load_i}{%
\subparagraph{\texorpdfstring{Method
\texttt{load\_i}}{Method load\_i}}\label{StrongCoupling.StrongCoupling.load_i}}

\begin{quote}
\begin{verbatim}
def load_i(
    self
)
\end{verbatim}
\end{quote}

load all IRCs i or recomptue

\hypertarget{StrongCoupling.StrongCoupling.load_k_sym}{%
\subparagraph{\texorpdfstring{Method
\texttt{load\_k\_sym}}{Method load\_k\_sym}}\label{StrongCoupling.StrongCoupling.load_k_sym}}

\begin{quote}
\begin{verbatim}
def load_k_sym(
    self
)
\end{verbatim}
\end{quote}

kA, kB contain the ith order terms of expanding the coupling fun. cA, cB
contain the derivatives of the coupling fn.

\hypertarget{StrongCoupling.StrongCoupling.load_limit_cycle}{%
\subparagraph{\texorpdfstring{Method
\texttt{load\_limit\_cycle}}{Method load\_limit\_cycle}}\label{StrongCoupling.StrongCoupling.load_limit_cycle}}

\begin{quote}
\begin{verbatim}
def load_limit_cycle(
    self
)
\end{verbatim}
\end{quote}

\hypertarget{StrongCoupling.StrongCoupling.load_monodromy}{%
\subparagraph{\texorpdfstring{Method
\texttt{load\_monodromy}}{Method load\_monodromy}}\label{StrongCoupling.StrongCoupling.load_monodromy}}

\begin{quote}
\begin{verbatim}
def load_monodromy(
    self
)
\end{verbatim}
\end{quote}

if monodromy data exists, load. if DNE or recompute required, compute
here.

\hypertarget{StrongCoupling.StrongCoupling.load_p}{%
\subparagraph{\texorpdfstring{Method
\texttt{load\_p}}{Method load\_p}}\label{StrongCoupling.StrongCoupling.load_p}}

\begin{quote}
\begin{verbatim}
def load_p(
    self
)
\end{verbatim}
\end{quote}

generate/load the ODEs for psi.

\hypertarget{StrongCoupling.StrongCoupling.load_p_sym}{%
\subparagraph{\texorpdfstring{Method
\texttt{load\_p\_sym}}{Method load\_p\_sym}}\label{StrongCoupling.StrongCoupling.load_p_sym}}

\begin{quote}
\begin{verbatim}
def load_p_sym(
    self
)
\end{verbatim}
\end{quote}

generate/load the het. terms for psi ODEs.

to be solved using integrating factor meothod.

pA{[}`sym'{]}{[}k{]} is the forcing function of order k

\hypertarget{StrongCoupling.StrongCoupling.load_z}{%
\subparagraph{\texorpdfstring{Method
\texttt{load\_z}}{Method load\_z}}\label{StrongCoupling.StrongCoupling.load_z}}

\begin{quote}
\begin{verbatim}
def load_z(
    self
)
\end{verbatim}
\end{quote}

load all PRCs z or recompute

\hypertarget{StrongCoupling.StrongCoupling.monodromy}{%
\subparagraph{\texorpdfstring{Method
\texttt{monodromy}}{Method monodromy}}\label{StrongCoupling.StrongCoupling.monodromy}}

\begin{quote}
\begin{verbatim}
def monodromy(
    self,
    t,
    z
)
\end{verbatim}
\end{quote}

calculate right-hand side of system

\(\dot \Phi = J\Phi, \Phi(0)=I\),

where \(\Phi\) is a matrix solution

jacLC is the jacobian evaluated along the limit cycle

\hypertarget{StrongCoupling.StrongCoupling.numerical_jac}{%
\subparagraph{\texorpdfstring{Method
\texttt{numerical\_jac}}{Method numerical\_jac}}\label{StrongCoupling.StrongCoupling.numerical_jac}}

\begin{quote}
\begin{verbatim}
def numerical_jac(
    self,
    fn,
    x,
    eps=1e-07
)
\end{verbatim}
\end{quote}

return numerical Jacobian function

\hypertarget{CGL}{%
\section{\texorpdfstring{Module \texttt{CGL}}{Module CGL}}\label{CGL}}

The logical flow of the class follows the paper by Wilson 2020. -produce
heterogeneous terms for g for arbirary dx -substitute dx with g=g0 +
psi\emph{g1 + psi\^{}2}g2+\ldots{} -produce het. terms for irc -

this file is also practice for creating a more general class for any
RHS.

Todo -----= -make sure that np.dot and sym matrix products are
consistent. -check that np.identity and sym.eye are consistent

\hypertarget{functions-1}{%
\subsection{Functions}\label{functions-1}}

\hypertarget{CGL.coupling}{%
\subsubsection{\texorpdfstring{Function
\texttt{coupling}}{Function coupling}}\label{CGL.coupling}}

\begin{quote}
\begin{verbatim}
def coupling(
    vars_pair,
    pdict,
    option='value'
)
\end{verbatim}
\end{quote}

r\^{}(2n) to r\^{}n function. default parameter order is from
perspective of first oscillator.

in this case the input is (x1,y1,x2,y2) and the output is an R\^{}2 vec.

\hypertarget{CGL.main}{%
\subsubsection{\texorpdfstring{Function
\texttt{main}}{Function main}}\label{CGL.main}}

\begin{quote}
\begin{verbatim}
def main()
\end{verbatim}
\end{quote}

\hypertarget{CGL.rhs}{%
\subsubsection{\texorpdfstring{Function
\texttt{rhs}}{Function rhs}}\label{CGL.rhs}}

\begin{quote}
\begin{verbatim}
def rhs(
    t,
    z,
    pdict,
    option='value'
)
\end{verbatim}
\end{quote}

right-hand side of the equation of interest. CCGL model.

write in standard python notation as if it will be used in an ODE
solver.

Returns

\begin{description}
\tightlist
\item[\texttt{right-hand\ side\ equauation\ in\ terms} of the inputs. if
x,y scalars,]
~
\end{description}

return scalar. If x,y, sympy symbols, return symbol.

\hypertarget{Thalamic}{%
\section{\texorpdfstring{Module
\texttt{Thalamic}}{Module Thalamic}}\label{Thalamic}}

file for comparing to CGL. implement adjoint methods in Wilson 2020

\url{https://stackoverflow.com/questions/49306092/parsing-a-symbolic-expression-that-includes-user-defined-functions-in-sympy}

user-defined

\hypertarget{functions-2}{%
\subsection{Functions}\label{functions-2}}

\hypertarget{Thalamic.coupling}{%
\subsubsection{\texorpdfstring{Function
\texttt{coupling}}{Function coupling}}\label{Thalamic.coupling}}

\begin{quote}
\begin{verbatim}
def coupling(
    vars_pair,
    pdict,
    option='val'
)
\end{verbatim}
\end{quote}

\hypertarget{Thalamic.main}{%
\subsubsection{\texorpdfstring{Function
\texttt{main}}{Function main}}\label{Thalamic.main}}

\begin{quote}
\begin{verbatim}
def main()
\end{verbatim}
\end{quote}

\hypertarget{Thalamic.rhs}{%
\subsubsection{\texorpdfstring{Function
\texttt{rhs}}{Function rhs}}\label{Thalamic.rhs}}

\begin{quote}
\begin{verbatim}
def rhs(
    t,
    z,
    pdict,
    option='val'
)
\end{verbatim}
\end{quote}

right-hand side of the equation of interest. thalamic neural model.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

Generated by \emph{pdoc} 0.9.1 (\url{https://pdoc3.github.io}).

\end{document}
