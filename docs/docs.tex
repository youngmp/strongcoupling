% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
\PassOptionsToPackage{dvipsnames,svgnames*,x11names*}{xcolor}
%
\documentclass[
  english,
  a4paper,
  oneside]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\hypersetup{
  pdfauthor={Youngmin Park},
  pdflang={en},
  colorlinks=true,
  linkcolor=blue,
  filecolor=Maroon,
  citecolor=Blue,
  urlcolor=Blue,
  pdfcreator={LaTeX via pandoc}}
\urlstyle{same} % disable monospaced font for URLs
\usepackage[margin=1in]{geometry}
\usepackage{longtable,booktabs}
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
% Make links footnotes instead of hotlinks:
\DeclareRobustCommand{\href}[2]{#2\footnote{\url{#1}}}
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{-\maxdimen} % remove section numbering
\ifxetex
  % Load polyglossia as late as possible: uses bidi with RTL langages (e.g. Hebrew, Arabic)
  \usepackage{polyglossia}
  \setmainlanguage[]{english}
\else
  \usepackage[shorthands=off,main=english]{babel}
\fi

\title{High-Order Accuracy Coumputation of Coupling Functions for Strongly
Coupled Oscllators (Documentation)}
\author{Youngmin Park}
\date{}

\begin{document}
\maketitle

{
\hypersetup{linkcolor=}
\setcounter{tocdepth}{4}
\tableofcontents
}
\hypertarget{introduction}{%
\section{Introduction}\label{introduction}}

StrongCoupling is a script for computing the higher-order coupling
functions in my paper with Dan Wilson, ``High-Order Accuracy Compuation
of Coupling Functions for Strongly Coupled Oscillators''

\hypertarget{dependencies}{%
\subsection{Dependencies}\label{dependencies}}

All following libraries are required to make the script run.

\begin{longtable}[]{@{}lll@{}}
\toprule
Package & Version & Link\tabularnewline
\midrule
\endhead
Python & 3.7.7 &\tabularnewline
Matplotlib & 3.3.1 &\tabularnewline
Numpy & 1.19.1 &\tabularnewline
Scipy & 1.5.2 &\tabularnewline
Pathos & 0.2.6 & https://anaconda.org/conda-forge/pathos\tabularnewline
tqdm & 4.48.2 & https://anaconda.org/conda-forge/tqdm\tabularnewline
Sympy & 1.6.2 & https://anaconda.org/anaconda/sympy\tabularnewline
\bottomrule
\end{longtable}

Notes on depedendencies:

\textbf{Python 3.7+ is necessary}. Our code often requires more than 256
function inputs. Python 3.6 or earlier versions have a limit of 256
inputs and will not work with our scripts. The script will likely work
with earlier versions of all other libraries.

\hypertarget{other-notes}{%
\subsubsection{Other Notes}\label{other-notes}}

I intentially chose \textbf{pathos} over multiprocessing because
pickling is more robust with pathos. Pathos uses dill, which can
serialize far more objects compared to multiprocessing, which uses
pickle.

The code is written so that tqdm is necessary, but tqdm only provides a
status bar during parallel computing. It is not part of the engine, and
the code can be modified to work without it. In future versions I may
leave tqdm as a toggle.

\hypertarget{installation}{%
\subsection{Installation}\label{installation}}

As long as your computer has the packages listed above and they are
installed using Python 3.7, the StrongCoupling script should run.

I will not release the StrongCoupling script as an installable package
simply because I do not have to time to maintain and track version
releases for distribution platforms such as anaconda, pip, and apt.
Worst case scenario, ``yarrr matey'' a Windows 10 virutal machine and
install everything using anaconda.

Note that in Ubuntu you may need to set up a virtual environment to be
able to run the StrongCoupling script. Ubuntu uses Python 3.6 by default
and does not like it when the default is changed to Python 3.7.

\hypertarget{StrongCoupling}{%
\section{\texorpdfstring{Module
\texttt{StrongCoupling}}{Module StrongCoupling}}\label{StrongCoupling}}

StrongCoupling.py computes the higher-order interaction functions from
Park and Wilson 2020 for \(N=2\) models and one Floquet multiplier.

In broad strokes, this library computes functions in the following
order:

\begin{itemize}
\tightlist
\item
  Use the equation for \(\Delta x\) (15) to produce a hierarchy of ODEs
  for \(g^{(k)}\) and solve. (Wilson 2020)
\item
  Do the same using (30) and (40) to generate a hierarchy of ODEs for
  \(Z^{(k)}\) and \(I^{(k)}\), respectively. (Wilson 2020)
\item
  Solve for \(\phi\) in terms of \(\theta_i\), (13), (14) (Park and
  Wilson 2020)
\item
  Compute the higher-order interaction functions (15) (Park and Wilson
  2020)
\end{itemize}

Notes: - pA requires endpoint=False. make sure corresponding dxAs are
used.

\hypertarget{functions}{%
\subsection{Functions}\label{functions}}

\hypertarget{StrongCoupling.module_exists}{%
\subsubsection{\texorpdfstring{Function
\texttt{module\_exists}}{Function module\_exists}}\label{StrongCoupling.module_exists}}

\begin{quote}
\begin{verbatim}
def module_exists(
    module_name
)
\end{verbatim}
\end{quote}

\hypertarget{classes}{%
\subsection{Classes}\label{classes}}

\hypertarget{StrongCoupling.StrongCoupling}{%
\subsubsection{\texorpdfstring{Class
\texttt{StrongCoupling}}{Class StrongCoupling}}\label{StrongCoupling.StrongCoupling}}

\begin{quote}
\begin{verbatim}
class StrongCoupling(
    rhs,
    coupling,
    LC_init,
    var_names,
    pardict,
    **kwargs
)
\end{verbatim}
\end{quote}

See the defaults dict below for allowed kwargs.

All model parameters must follow the convention `parameter\_val'. No
other underscores should be used. the script splits the parameter name
at '\_' and uses the string to the left as the sympy parmeter name.

Reserved names: \ldots{}

g\_forward: list or bool. If bool, integrate forwards or backwards when
computing g\^{}k. If list, integrate g\^{}k forwards or backwards based
on bool value g\_forward{[}k{]} z\_forward: list or bool. Same idea as
g\_forward for PRCS i\_forward: list or bool. Same idea as g\_forward
for IRCS

g\_bad\_dx: list or bool. If bool, use another variable to increase the
magnitude of the Newton derivative. This can only be determined after
attempting to run simulations and seeing that the Jacobian for the
Newton step is ill-conditioned. If list, check for ill-conditioning for
each order k. For example, we use g\_small\_dx =
{[}False,True,False,\ldots,False{]} for the thalamic model. The CGL
model only needs g\_small\_idx = False z\_bad\_idx: same idea as
g\_small\_idx for PRCs i\_bad\_idx: same idea as g\_small\_idx for IRCs

coupling\_pars: str. example: input '\_d='+str(d\_par) to include the d
parameter d\_par in the hodd function name.

\hypertarget{methods}{%
\paragraph{Methods}\label{methods}}

\hypertarget{StrongCoupling.StrongCoupling.bispeu}{%
\subparagraph{\texorpdfstring{Method
\texttt{bispeu}}{Method bispeu}}\label{StrongCoupling.StrongCoupling.bispeu}}

\begin{quote}
\begin{verbatim}
def bispeu(
    self,
    fn,
    x,
    y
)
\end{verbatim}
\end{quote}

silly workaround \url{https://stackoverflow.com/questions/47087109/...}
evaluate-the-output-from-scipy-2d-interpolation-along-a-curve

\hypertarget{StrongCoupling.StrongCoupling.dg}{%
\subparagraph{\texorpdfstring{Method
\texttt{dg}}{Method dg}}\label{StrongCoupling.StrongCoupling.dg}}

\begin{quote}
\begin{verbatim}
def dg(
    self,
    t,
    z,
    order,
    het_vec
)
\end{verbatim}
\end{quote}

g functon rhs with ith het. term

z: position t: time jacLC: jacobian on LC het: heterogeneous terms

order determines the Taylor expansion term

\hypertarget{StrongCoupling.StrongCoupling.di}{%
\subparagraph{\texorpdfstring{Method
\texttt{di}}{Method di}}\label{StrongCoupling.StrongCoupling.di}}

\begin{quote}
\begin{verbatim}
def di(
    self,
    t,
    z,
    order,
    het_vec
)
\end{verbatim}
\end{quote}

g functon rhs with ith het. term

z: position t: time jacLC: jacobian on LC het: heterogeneous terms

order determines the Taylor expansion term

\hypertarget{StrongCoupling.StrongCoupling.dz}{%
\subparagraph{\texorpdfstring{Method
\texttt{dz}}{Method dz}}\label{StrongCoupling.StrongCoupling.dz}}

\begin{quote}
\begin{verbatim}
def dz(
    self,
    t,
    z,
    order,
    het_vec
)
\end{verbatim}
\end{quote}

g functon rhs with ith het. term

z: position t: time jacLC: jacobian on LC het: heterogeneous terms

order determines the Taylor expansion term

\hypertarget{StrongCoupling.StrongCoupling.fLam2}{%
\subparagraph{\texorpdfstring{Method
\texttt{fLam2}}{Method fLam2}}\label{StrongCoupling.StrongCoupling.fLam2}}

\begin{quote}
\begin{verbatim}
def fLam2(
    self,
    fn
)
\end{verbatim}
\end{quote}

interp2db object

\hypertarget{StrongCoupling.StrongCoupling.fmod}{%
\subparagraph{\texorpdfstring{Method
\texttt{fmod}}{Method fmod}}\label{StrongCoupling.StrongCoupling.fmod}}

\begin{quote}
\begin{verbatim}
def fmod(
    self,
    fn
)
\end{verbatim}
\end{quote}

fn has mod built-in

input function-like. usually interp1d object

needed to keep lambda input variable unique to fn.

otherwise lambda will use the same input variable for all lambda
functions.

\hypertarget{StrongCoupling.StrongCoupling.generate_expansions}{%
\subparagraph{\texorpdfstring{Method
\texttt{generate\_expansions}}{Method generate\_expansions}}\label{StrongCoupling.StrongCoupling.generate_expansions}}

\begin{quote}
\begin{verbatim}
def generate_expansions(
    self
)
\end{verbatim}
\end{quote}

generate expansions from Wilson 2020

\hypertarget{StrongCoupling.StrongCoupling.generate_g}{%
\subparagraph{\texorpdfstring{Method
\texttt{generate\_g}}{Method generate\_g}}\label{StrongCoupling.StrongCoupling.generate_g}}

\begin{quote}
\begin{verbatim}
def generate_g(
    self,
    k,
    het_vec
)
\end{verbatim}
\end{quote}

generate Floquet eigenfunctions g

uses Newtons method

\hypertarget{StrongCoupling.StrongCoupling.generate_h_odd}{%
\subparagraph{\texorpdfstring{Method
\texttt{generate\_h\_odd}}{Method generate\_h\_odd}}\label{StrongCoupling.StrongCoupling.generate_h_odd}}

\begin{quote}
\begin{verbatim}
def generate_h_odd(
    self,
    k
)
\end{verbatim}
\end{quote}

interaction functions

note to self: see nb page 130 for notes on indexing in sums. need to sum
over to index N-1 out of size N to avoid double counting boundaries in
mod operator.

\hypertarget{StrongCoupling.StrongCoupling.generate_het_sym}{%
\subparagraph{\texorpdfstring{Method
\texttt{generate\_het\_sym}}{Method generate\_het\_sym}}\label{StrongCoupling.StrongCoupling.generate_het_sym}}

\begin{quote}
\begin{verbatim}
def generate_het_sym(
    self
)
\end{verbatim}
\end{quote}

Generate heterogeneous terms for integrating the Z\_i and I\_i terms.

Returns

None.

\hypertarget{StrongCoupling.StrongCoupling.generate_i}{%
\subparagraph{\texorpdfstring{Method
\texttt{generate\_i}}{Method generate\_i}}\label{StrongCoupling.StrongCoupling.generate_i}}

\begin{quote}
\begin{verbatim}
def generate_i(
    self,
    k,
    het_vec
)
\end{verbatim}
\end{quote}

i0 equation is stable in forwards time i1, i2, etc equations are stable
in backwards time.

\hypertarget{StrongCoupling.StrongCoupling.generate_k_sym}{%
\subparagraph{\texorpdfstring{Method
\texttt{generate\_k\_sym}}{Method generate\_k\_sym}}\label{StrongCoupling.StrongCoupling.generate_k_sym}}

\begin{quote}
\begin{verbatim}
def generate_k_sym(
    self
)
\end{verbatim}
\end{quote}

\hypertarget{StrongCoupling.StrongCoupling.generate_limit_cycle}{%
\subparagraph{\texorpdfstring{Method
\texttt{generate\_limit\_cycle}}{Method generate\_limit\_cycle}}\label{StrongCoupling.StrongCoupling.generate_limit_cycle}}

\begin{quote}
\begin{verbatim}
def generate_limit_cycle(
    self
)
\end{verbatim}
\end{quote}

\hypertarget{StrongCoupling.StrongCoupling.generate_p}{%
\subparagraph{\texorpdfstring{Method
\texttt{generate\_p}}{Method generate\_p}}\label{StrongCoupling.StrongCoupling.generate_p}}

\begin{quote}
\begin{verbatim}
def generate_p(
    self,
    k
)
\end{verbatim}
\end{quote}

\hypertarget{StrongCoupling.StrongCoupling.generate_p_old}{%
\subparagraph{\texorpdfstring{Method
\texttt{generate\_p\_old}}{Method generate\_p\_old}}\label{StrongCoupling.StrongCoupling.generate_p_old}}

\begin{quote}
\begin{verbatim}
def generate_p_old(
    self,
    k
)
\end{verbatim}
\end{quote}

\hypertarget{StrongCoupling.StrongCoupling.generate_z}{%
\subparagraph{\texorpdfstring{Method
\texttt{generate\_z}}{Method generate\_z}}\label{StrongCoupling.StrongCoupling.generate_z}}

\begin{quote}
\begin{verbatim}
def generate_z(
    self,
    k,
    het_vec
)
\end{verbatim}
\end{quote}

\hypertarget{StrongCoupling.StrongCoupling.interp_lam}{%
\subparagraph{\texorpdfstring{Method
\texttt{interp\_lam}}{Method interp\_lam}}\label{StrongCoupling.StrongCoupling.interp_lam}}

\begin{quote}
\begin{verbatim}
def interp_lam(
    self,
    k,
    fn_dict,
    fn_type='z'
)
\end{verbatim}
\end{quote}

it is too slow to call individual interpolated functions in the symbolic
heterogeneous terms. soince the heterogeneous terms only depend on t,
just make and interpolated version and use that instead so only 1
function is called for the het. terms per iteration in numerical
iteration.

\hypertarget{StrongCoupling.StrongCoupling.load_g}{%
\subparagraph{\texorpdfstring{Method
\texttt{load\_g}}{Method load\_g}}\label{StrongCoupling.StrongCoupling.load_g}}

\begin{quote}
\begin{verbatim}
def load_g(
    self
)
\end{verbatim}
\end{quote}

load all Floquet eigenfunctions g or recompute

\hypertarget{StrongCoupling.StrongCoupling.load_g_sym}{%
\subparagraph{\texorpdfstring{Method
\texttt{load\_g\_sym}}{Method load\_g\_sym}}\label{StrongCoupling.StrongCoupling.load_g_sym}}

\begin{quote}
\begin{verbatim}
def load_g_sym(
    self
)
\end{verbatim}
\end{quote}

\hypertarget{StrongCoupling.StrongCoupling.load_h}{%
\subparagraph{\texorpdfstring{Method
\texttt{load\_h}}{Method load\_h}}\label{StrongCoupling.StrongCoupling.load_h}}

\begin{quote}
\begin{verbatim}
def load_h(
    self
)
\end{verbatim}
\end{quote}

\hypertarget{StrongCoupling.StrongCoupling.load_h_sym}{%
\subparagraph{\texorpdfstring{Method
\texttt{load\_h\_sym}}{Method load\_h\_sym}}\label{StrongCoupling.StrongCoupling.load_h_sym}}

\begin{quote}
\begin{verbatim}
def load_h_sym(
    self
)
\end{verbatim}
\end{quote}

also compute h lam

\hypertarget{StrongCoupling.StrongCoupling.load_het_sym}{%
\subparagraph{\texorpdfstring{Method
\texttt{load\_het\_sym}}{Method load\_het\_sym}}\label{StrongCoupling.StrongCoupling.load_het_sym}}

\begin{quote}
\begin{verbatim}
def load_het_sym(
    self
)
\end{verbatim}
\end{quote}

\hypertarget{StrongCoupling.StrongCoupling.load_i}{%
\subparagraph{\texorpdfstring{Method
\texttt{load\_i}}{Method load\_i}}\label{StrongCoupling.StrongCoupling.load_i}}

\begin{quote}
\begin{verbatim}
def load_i(
    self
)
\end{verbatim}
\end{quote}

load all IRCs i or recomptue

\hypertarget{StrongCoupling.StrongCoupling.load_k_sym}{%
\subparagraph{\texorpdfstring{Method
\texttt{load\_k\_sym}}{Method load\_k\_sym}}\label{StrongCoupling.StrongCoupling.load_k_sym}}

\begin{quote}
\begin{verbatim}
def load_k_sym(
    self
)
\end{verbatim}
\end{quote}

kA, kB contain the ith order terms of expanding the coupling fun. cA, cB
contain the derivatives of the coupling fn.

\hypertarget{StrongCoupling.StrongCoupling.load_limit_cycle}{%
\subparagraph{\texorpdfstring{Method
\texttt{load\_limit\_cycle}}{Method load\_limit\_cycle}}\label{StrongCoupling.StrongCoupling.load_limit_cycle}}

\begin{quote}
\begin{verbatim}
def load_limit_cycle(
    self
)
\end{verbatim}
\end{quote}

\hypertarget{StrongCoupling.StrongCoupling.load_monodromy}{%
\subparagraph{\texorpdfstring{Method
\texttt{load\_monodromy}}{Method load\_monodromy}}\label{StrongCoupling.StrongCoupling.load_monodromy}}

\begin{quote}
\begin{verbatim}
def load_monodromy(
    self
)
\end{verbatim}
\end{quote}

if monodromy data exists, load. if DNE or recompute required, compute
here.

\hypertarget{StrongCoupling.StrongCoupling.load_p}{%
\subparagraph{\texorpdfstring{Method
\texttt{load\_p}}{Method load\_p}}\label{StrongCoupling.StrongCoupling.load_p}}

\begin{quote}
\begin{verbatim}
def load_p(
    self
)
\end{verbatim}
\end{quote}

generate/load the ODEs for psi.

\hypertarget{StrongCoupling.StrongCoupling.load_p_sym}{%
\subparagraph{\texorpdfstring{Method
\texttt{load\_p\_sym}}{Method load\_p\_sym}}\label{StrongCoupling.StrongCoupling.load_p_sym}}

\begin{quote}
\begin{verbatim}
def load_p_sym(
    self
)
\end{verbatim}
\end{quote}

generate/load the het. terms for psi ODEs.

to be solved using integrating factor meothod.

pA{[}`sym'{]}{[}k{]} is the forcing function of order k

\hypertarget{StrongCoupling.StrongCoupling.load_z}{%
\subparagraph{\texorpdfstring{Method
\texttt{load\_z}}{Method load\_z}}\label{StrongCoupling.StrongCoupling.load_z}}

\begin{quote}
\begin{verbatim}
def load_z(
    self
)
\end{verbatim}
\end{quote}

load all PRCs z or recompute

\hypertarget{StrongCoupling.StrongCoupling.monodromy}{%
\subparagraph{\texorpdfstring{Method
\texttt{monodromy}}{Method monodromy}}\label{StrongCoupling.StrongCoupling.monodromy}}

\begin{quote}
\begin{verbatim}
def monodromy(
    self,
    t,
    z
)
\end{verbatim}
\end{quote}

calculate right-hand side of system

\(\dot \Phi = J\Phi, \Phi(0)=I\),

where \(\Phi\) is a matrix solution

jacLC is the jacobian evaluated along the limit cycle

\hypertarget{StrongCoupling.StrongCoupling.numerical_jac}{%
\subparagraph{\texorpdfstring{Method
\texttt{numerical\_jac}}{Method numerical\_jac}}\label{StrongCoupling.StrongCoupling.numerical_jac}}

\begin{quote}
\begin{verbatim}
def numerical_jac(
    self,
    fn,
    x,
    eps=1e-07
)
\end{verbatim}
\end{quote}

return numerical Jacobian function

\hypertarget{Thalamic}{%
\section{\texorpdfstring{Module
\texttt{Thalamic}}{Module Thalamic}}\label{Thalamic}}

Example: Thalamic model from Wilson and Ermentrout RSTA 2019, Rubin and
Terman JCNS 2004

\hypertarget{functions-1}{%
\subsection{Functions}\label{functions-1}}

\hypertarget{Thalamic.coupling}{%
\subsubsection{\texorpdfstring{Function
\texttt{coupling}}{Function coupling}}\label{Thalamic.coupling}}

\begin{quote}
\begin{verbatim}
def coupling(
    vars_pair,
    pdict,
    option='val'
)
\end{verbatim}
\end{quote}

Synaptic coupling function between Thalamic oscillators.

E.g.,this Python function is the function \(G(x_i,x_j)\) in the equation
\(\frac{dx_i}{dt} = F(x_i) + \varepsilon G(x_i,x_j)\)

Parameters

\begin{verbatim}
vars_pair : list or array
    contains state variables from oscillator A and B, e.g.,
    vA, hA, rA, wA, vB, hB, rB, wB  
pdict : dict of flots or sympy objects.
    parameter dictionary pdict[key], val. key is always a string
    of the parameter. val is either the parameter value (float) or 
    the symbolic version of the parameter key.
option : string.
    Set to 'val' when inputs, t, z, pdict are floats. Set to
    'sym' when inputs t, z, pdict are sympy objects. The default
    is 'val'.
\end{verbatim}

Returns

\begin{verbatim}
numpy array or sympy Matrix
    returns numpy array if option == 'val'. 
    returns sympy Matrix if option == 'sym'
\end{verbatim}

\hypertarget{Thalamic.main}{%
\subsubsection{\texorpdfstring{Function
\texttt{main}}{Function main}}\label{Thalamic.main}}

\begin{quote}
\begin{verbatim}
def main()
\end{verbatim}
\end{quote}

\hypertarget{Thalamic.rhs}{%
\subsubsection{\texorpdfstring{Function
\texttt{rhs}}{Function rhs}}\label{Thalamic.rhs}}

\begin{quote}
\begin{verbatim}
def rhs(
    t,
    z,
    pdict,
    option='val'
)
\end{verbatim}
\end{quote}

Right-hand side of the Thalamic model from Wilson and Ermentrout RSTA
2019 and Rubin and Terman JCNS 2004

Parameters

\begin{verbatim}
t : float or sympy object.
    time
z : array or list of floats or sympy objects.
    state variables of the thalamic model v, h, r, w.
pdict : dict of flots or sympy objects.
    parameter dictionary pdict[key], val. key is always a string
    of the parameter. val is either the parameter value (float) or 
    the symbolic version of the parameter key.
option : string.
    Set to 'val' when inputs, t, z, pdict are floats. Set to
    'sym' when inputs t, z, pdict are sympy objects. The default
    is 'val'.
\end{verbatim}

Returns

\begin{verbatim}
numpy array or sympy Matrix
    returns numpy array if option == 'val'
    returns sympy Matrix if option == 'sym'
\end{verbatim}

\hypertarget{CGL}{%
\section{\texorpdfstring{Module \texttt{CGL}}{Module CGL}}\label{CGL}}

Example: Complex Ginzburgh-Landau (CGL) model from Wilson and Ermentrout
RSTA 2019

\hypertarget{functions-2}{%
\subsection{Functions}\label{functions-2}}

\hypertarget{CGL.coupling}{%
\subsubsection{\texorpdfstring{Function
\texttt{coupling}}{Function coupling}}\label{CGL.coupling}}

\begin{quote}
\begin{verbatim}
def coupling(
    vars_pair,
    pdict,
    option='value'
)
\end{verbatim}
\end{quote}

Diffusive coupling function between Complex Ginzburgh Landau (CGL)
oscillators.

E.g.,this Python function is the function \(G(x_i,x_j)\) in the equation
\(\frac{dx_i}{dt} = F(x_i) + \varepsilon G(x_i,x_j)\)

Parameters

\begin{verbatim}
vars_pair : list or array
    contains state variables from oscillator A and B, e.g.,
    x1,y1,x2,y2
pdict : dict of flots or sympy objects.
    parameter dictionary pdict[key], val. key is always a string
    of the parameter. val is either the parameter value (float) or 
    the symbolic version of the parameter key.
option : string.
    Set to 'val' when inputs, t, z, pdict are floats. Set to
    'sym' when inputs t, z, pdict are sympy objects. The default
    is 'val'.
\end{verbatim}

Returns

\begin{verbatim}
* numpy array or sympy Matrix
    * returns numpy array if option == 'val'. 
    returns sympy Matrix if option == 'sym'
\end{verbatim}

\hypertarget{CGL.main}{%
\subsubsection{\texorpdfstring{Function
\texttt{main}}{Function main}}\label{CGL.main}}

\begin{quote}
\begin{verbatim}
def main()
\end{verbatim}
\end{quote}

\hypertarget{CGL.rhs}{%
\subsubsection{\texorpdfstring{Function
\texttt{rhs}}{Function rhs}}\label{CGL.rhs}}

\begin{quote}
\begin{verbatim}
def rhs(
    t,
    z,
    pdict,
    option='value'
)
\end{verbatim}
\end{quote}

Right-hand side of the Complex Ginzburgh-Landau (CGL) model from Wilson
and Ermentrout RSTA 2019

Parameters

\begin{verbatim}
t : float or sympy object.
    time
z : array or list of floats or sympy objects.
    state variables of the thalamic model v, h, r, w.
pdict : dict of flots or sympy objects.
    parameter dictionary pdict[key], val. key is always a string
    of the parameter. val is either the parameter value (float) or 
    the symbolic version of the parameter key.
option : string.
    Set to 'val' when inputs, t, z, pdict are floats. Set to
    'sym' when inputs t, z, pdict are sympy objects. The default
    is 'val'.
\end{verbatim}

Returns

\begin{verbatim}
numpy array or sympy Matrix
    returns numpy array if option == 'val'
    returns sympy Matrix if option == 'sym'
\end{verbatim}

Generated by \emph{pdoc} 0.9.1 (\url{https://pdoc3.github.io}).

\end{document}
