\documentclass[english,a4paper,oneside]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Ligatures=TeX,Scale=MatchLowercase}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{%
\usepackage[]{microtype}
\UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\PassOptionsToPackage{hyphens}{url} % url is loaded by hyperref
\usepackage[unicode=true]{hyperref}
\PassOptionsToPackage{usenames,dvipsnames}{color} % color is loaded by hyperref
\hypersetup{
            pdfauthor={Youngmin Park},
            colorlinks=true,
            linkcolor=blue,
            citecolor=Blue,
            urlcolor=Blue,
            breaklinks=true}
\urlstyle{same}  % don't use monospace font for urls
\usepackage[margin=1in]{geometry}
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[shorthands=off,main=english]{babel}
\else
  \usepackage{polyglossia}
  \setmainlanguage[]{english}
\fi
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\newenvironment{Shaded}{}{}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{#1}}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{#1}}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{#1}}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{#1}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{#1}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\usepackage{longtable,booktabs}
% Fix footnotes in tables (requires footnote package)
\IfFileExists{footnote.sty}{\usepackage{footnote}\makesavenoteenv{long table}}{}
% Make links footnotes instead of hotlinks:
\renewcommand{\href}[2]{#2\footnote{\url{#1}}}
\IfFileExists{parskip.sty}{%
\usepackage{parskip}
}{% else
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{0}
% Redefines (sub)paragraphs to behave more like sections
\ifx\paragraph\undefined\else
\let\oldparagraph\paragraph
\renewcommand{\paragraph}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
\let\oldsubparagraph\subparagraph
\renewcommand{\subparagraph}[1]{\oldsubparagraph{#1}\mbox{}}
\fi

% set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother


\title{true}
\author{Youngmin Park}
\date{}

\begin{document}
\maketitle

{
\hypersetup{linkcolor=black}
\setcounter{tocdepth}{4}
\tableofcontents
}
\section{Introduction}\label{introduction}

StrongCoupling is a script for computing the higher-order coupling
functions in my paper with Dan Wilson, ``High-Order Accuracy Compuation
of Coupling Functions for Strongly Coupled Oscillators''. The script
generates higher-order interaction functions to be used in phase models.

\subsection{Dependencies}\label{dependencies}

All following libraries are required to make the script run.

\begin{longtable}[]{@{}lll@{}}
\toprule
Package & Version & Link\tabularnewline
\midrule
\endhead
Python & 3.7.7 &\tabularnewline
Matplotlib & 3.3.1 &\tabularnewline
Numpy & 1.19.1 &\tabularnewline
Scipy & 1.5.2 &\tabularnewline
Pathos & 0.2.6 & https://anaconda.org/conda-forge/pathos\tabularnewline
tqdm & 4.48.2 & https://anaconda.org/conda-forge/tqdm\tabularnewline
Sympy & 1.6.2 & https://anaconda.org/anaconda/sympy\tabularnewline
\bottomrule
\end{longtable}

Notes on depedendencies:

\textbf{Python 3.7+ is necessary}. Our code often requires more than 256
function inputs. Python 3.6 or earlier versions have a limit of 256
inputs and will not work with our scripts. The script will likely work
with earlier versions of all other libraries.

\subsubsection{Other Notes}\label{other-notes}

I intentially chose \textbf{pathos} over multiprocessing because
pickling is more robust with pathos. Pathos uses dill, which can
serialize far more objects compared to multiprocessing, which uses
pickle.

The code is written so that tqdm is necessary, but tqdm only provides a
status bar during parallel computing. It is not part of the engine, and
the code can be modified to work without it. In future versions I may
leave tqdm as a toggle.

\subsection{Installation}\label{installation}

As long as your computer has the packages listed above and they are
installed using Python 3.7, the StrongCoupling script should run.

I have no immediate plans to release the StrongCoupling script as an
installable package simply because I do not have to time to maintain and
track version releases for distribution platforms such as anaconda, pip,
and apt.

Note that in Ubuntu a virtual environment should be used to run the
StrongCoupling script. Ubuntu uses Python 3.6 by default and does not
like it when the default is changed to Python 3.7.

\section{Reproduce Figures}\label{reproduce-figures}

To reproduce the figures in Park and Wilson 2020, run

\$ generate\_figures.py

in the examples directory. This file will call the complex
Ginzburg-Landau (CGL) model file (CGL.py) and the thalamic model file
(Thalamic.py) and generate the figure files. It will take a while to
run, and will use 4 cores by default! Make sure to edit the keyword
arguments (documented in the StrongCoupling section below) if you wish
to use more or less cores.

\section{Set up a Model}\label{set-up-a-model}

Let's walk through setting up a script using the Goodwin oscillator
(\href{https://www.ncbi.nlm.nih.gov/pmc/articles/PMC1366510/}{Gonze et
al 2005}):

\[\frac{dX_i}{dt} = \nu_1 \frac{K_1^n}{K_1^n+Z_i^n} - \nu_2 \frac{X_i}{K_2 + X_i}+ \nu_c \frac{KF}{K_c + KF} + L,\]
\[\frac{dY_i}{dt} = k_3 X_i - \nu_4 \frac{Y_i}{K_4 + Y_i},\]
\[\frac{dZ_i}{dt} = k_5 Y_i - \nu_6 \frac{Z_i}{K_6 + Z_i}.\]

The neurotransmitter concentration satisfies:

\[\frac{dV_i}{dt} = k_7 X_i - \nu_8 \frac{V_i}{K_8 + V_i},\]

and the coupling \(F\) is defined as

\[F = \frac{1}{N}\sum_{i=1}^N V_i.\]

\subsection{Right-hand Side and Coupling
Function}\label{right-hand-side-and-coupling-function}

To use StrongCoupling, define a right-hand side function with the name
\texttt{rhs\textquotesingle{}\textquotesingle{},\ and\ a\ coupling\ function\ named}coupling''.
rhs is defined for a single oscillator:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ rhs(t,z,pdict,option}\OperatorTok{=}\StringTok{'value'}\NormalTok{):}
\NormalTok{    x,y,z,v }\OperatorTok{=}\NormalTok{ z}
    
\NormalTok{    p }\OperatorTok{=}\NormalTok{ pdict}
\NormalTok{    n }\OperatorTok{=}\NormalTok{ p[}\StringTok{'n'}\NormalTok{]}
    
\NormalTok{    dx }\OperatorTok{=}\NormalTok{ p[}\StringTok{'v1'}\NormalTok{]}\OperatorTok{*}\NormalTok{p[}\StringTok{'k1'}\NormalTok{]}\OperatorTok{**}\NormalTok{n}\OperatorTok{/}\NormalTok{(p[}\StringTok{'k1'}\NormalTok{]}\OperatorTok{**}\NormalTok{n}\OperatorTok{+}\NormalTok{z}\OperatorTok{**}\NormalTok{n) }\OperatorTok{-}\NormalTok{ p[}\StringTok{'v2'}\NormalTok{]}\OperatorTok{*}\NormalTok{x}\OperatorTok{/}\NormalTok{(p[}\StringTok{'k2'}\NormalTok{]}\OperatorTok{+}\NormalTok{x) }\OperatorTok{+}\NormalTok{ p[}\StringTok{'L'}\NormalTok{]}
\NormalTok{    dy }\OperatorTok{=}\NormalTok{ p[}\StringTok{'k3'}\NormalTok{]}\OperatorTok{*}\NormalTok{x }\OperatorTok{-}\NormalTok{ p[}\StringTok{'v4'}\NormalTok{]}\OperatorTok{*}\NormalTok{y}\OperatorTok{/}\NormalTok{(p[}\StringTok{'k4'}\NormalTok{]}\OperatorTok{+}\NormalTok{y)}
\NormalTok{    dz }\OperatorTok{=}\NormalTok{ p[}\StringTok{'k5'}\NormalTok{]}\OperatorTok{*}\NormalTok{y }\OperatorTok{-}\NormalTok{ p[}\StringTok{'v6'}\NormalTok{]}\OperatorTok{*}\NormalTok{z}\OperatorTok{/}\NormalTok{(p[}\StringTok{'k6'}\NormalTok{]}\OperatorTok{+}\NormalTok{z)}
\NormalTok{    dv }\OperatorTok{=}\NormalTok{ p[}\StringTok{'k7'}\NormalTok{]}\OperatorTok{*}\NormalTok{x }\OperatorTok{-}\NormalTok{ p[}\StringTok{'v8'}\NormalTok{]}\OperatorTok{*}\NormalTok{v}\OperatorTok{/}\NormalTok{(p[}\StringTok{'k8'}\NormalTok{]}\OperatorTok{+}\NormalTok{v)}
    
    \ControlFlowTok{if}\NormalTok{ option }\OperatorTok{==} \StringTok{'value'}\NormalTok{:}
        \ControlFlowTok{return}\NormalTok{ np.array([dx,dy,dz,dv])}
    \ControlFlowTok{elif}\NormalTok{ option }\OperatorTok{==} \StringTok{'sym'}\NormalTok{:}
        \ControlFlowTok{return}\NormalTok{ Matrix([dx,dy,dz,dv])}
\end{Highlighting}
\end{Shaded}

The input t is time and the input z is an array or list containing all
the variables. pdict contains all the parameters in a dictionary. It is
important to pdict treat as a dict because the rhs function plays two
roles. One, the rhs function is put into scipy ODE solvers, in which
case pdict contains key-value pairs of parameters and floats. Two, we
sometimes take symbolic derivatives of the rhs function, in which case
pdict contains key-value pairs of parameters and sympy objects. The
option input is used by StrongCoupling to help the rhs function return
the correct format for numeric or symbolic manipulation.

The coupling function is also defined for a single oscillator from the
perspective of the first oscillator:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ coupling(vars_pair,pdict,option}\OperatorTok{=}\StringTok{'value'}\NormalTok{):}
\NormalTok{    x1,y1,z1,v1,x2,y2,z2,v2 }\OperatorTok{=}\NormalTok{ vars_pair}
    
\NormalTok{    K }\OperatorTok{=}\NormalTok{ pdict[}\StringTok{'K'}\NormalTok{]}
\NormalTok{    vc }\OperatorTok{=}\NormalTok{ pdict[}\StringTok{'eps'}\NormalTok{]}
\NormalTok{    F }\OperatorTok{=} \FloatTok{0.5}\OperatorTok{*}\NormalTok{(v1}\OperatorTok{+}\NormalTok{v2)}
    
    \ControlFlowTok{if}\NormalTok{ option }\OperatorTok{==} \StringTok{'value'}\NormalTok{:}
        \ControlFlowTok{return}\NormalTok{ np.array([vc}\OperatorTok{*}\NormalTok{K}\OperatorTok{*}\NormalTok{F,}\DecValTok{0}\NormalTok{,}\DecValTok{0}\NormalTok{,}\DecValTok{0}\NormalTok{])}
    \ControlFlowTok{elif}\NormalTok{ option }\OperatorTok{==} \StringTok{'sym'}\NormalTok{:}
        \ControlFlowTok{return}\NormalTok{ Matrix([vc}\OperatorTok{*}\NormalTok{K}\OperatorTok{*}\NormalTok{F,}\DecValTok{0}\NormalTok{,}\DecValTok{0}\NormalTok{,}\DecValTok{0}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

Note that the parameter vc is the coupling parameter in the paper, so we
let it take the value of the parameter epsilon. Next, define a main()
function where we define the variables, parameter dictionary, keyword
options, limit cycle initial condition, and the StrongCoupling call.

\subsection{Set Up Keyword Arguments}\label{set-up-keyword-arguments}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ main():}
\NormalTok{    var_names }\OperatorTok{=}\NormalTok{ [}\StringTok{'x'}\NormalTok{,}\StringTok{'y'}\NormalTok{,}\StringTok{'z'}\NormalTok{,}\StringTok{'v'}\NormalTok{]}
\NormalTok{    pardict }\OperatorTok{=}\NormalTok{ \{}\StringTok{'v1_val'}\NormalTok{:.}\DecValTok{84}\NormalTok{,}\StringTok{'v2_val'}\NormalTok{:.}\DecValTok{42}\NormalTok{,}\StringTok{'v4_val'}\NormalTok{:.}\DecValTok{35}\NormalTok{,}\StringTok{'v6_val'}\NormalTok{:.}\DecValTok{35}\NormalTok{,}\StringTok{'v8_val'}\NormalTok{:}\DecValTok{1}\NormalTok{,}
               \StringTok{'k1_val'}\NormalTok{:}\DecValTok{1}\NormalTok{,}\StringTok{'k2_val'}\NormalTok{:}\DecValTok{1}\NormalTok{,}\StringTok{'k3_val'}\NormalTok{:.}\DecValTok{7}\NormalTok{,}\StringTok{'k4_val'}\NormalTok{:}\DecValTok{1}\NormalTok{,}\StringTok{'k5_val'}\NormalTok{:.}\DecValTok{7}\NormalTok{,}
               \StringTok{'k6_val'}\NormalTok{:}\DecValTok{1}\NormalTok{,}\StringTok{'k7_val'}\NormalTok{:.}\DecValTok{35}\NormalTok{,}\StringTok{'k8_val'}\NormalTok{:}\DecValTok{1}\NormalTok{,}\StringTok{'K_val'}\NormalTok{:}\FloatTok{0.5}\NormalTok{,}\StringTok{'kc_val'}\NormalTok{:}\DecValTok{1}\NormalTok{,}
               \StringTok{'n_val'}\NormalTok{:}\DecValTok{6}\NormalTok{,}\StringTok{'L_val'}\NormalTok{:}\DecValTok{0}\NormalTok{,}\StringTok{'eps_val'}\NormalTok{:}\DecValTok{0}\NormalTok{\}}
    
\NormalTok{    kwargs }\OperatorTok{=}\NormalTok{ \{}\StringTok{'g_forward'}\NormalTok{:}\VariableTok{True}\NormalTok{,}\StringTok{'z_forward'}\NormalTok{:}\VariableTok{False}\NormalTok{,}\StringTok{'i_forward'}\NormalTok{:}\VariableTok{False}\NormalTok{,}
              \StringTok{'i_bad_dx'}\NormalTok{:[}\VariableTok{False}\NormalTok{,}\VariableTok{True}\NormalTok{,}\VariableTok{False}\NormalTok{,}\VariableTok{False}\NormalTok{,}\VariableTok{False}\NormalTok{,}\VariableTok{False}\NormalTok{],}
              \StringTok{'dense'}\NormalTok{:}\VariableTok{True}\NormalTok{,}
              \StringTok{'dir'}\NormalTok{:}\StringTok{'home+goodwin_dat/'}\NormalTok{,}
              \StringTok{'trunc_order'}\NormalTok{:}\DecValTok{5}\NormalTok{,}
              \StringTok{'trunc_deriv'}\NormalTok{:}\DecValTok{5}\NormalTok{,}
              \StringTok{'NA'}\NormalTok{:}\DecValTok{2000}\NormalTok{,}
              \StringTok{'p_iter'}\NormalTok{:}\DecValTok{20}\NormalTok{,}
              \StringTok{'max_iter'}\NormalTok{:}\DecValTok{200}\NormalTok{,}
              \StringTok{'TN'}\NormalTok{:}\DecValTok{2000}\NormalTok{,}
              \StringTok{'rtol'}\NormalTok{:}\FloatTok{1e-13}\NormalTok{,}
              \StringTok{'atol'}\NormalTok{:}\FloatTok{1e-13}\NormalTok{,}
              \StringTok{'rel_tol'}\NormalTok{:}\FloatTok{1e-10}\NormalTok{,}
              \StringTok{'method'}\NormalTok{:}\StringTok{'LSODA'}\NormalTok{,}
              \StringTok{'processes'}\NormalTok{:}\DecValTok{4}\NormalTok{,}
              \StringTok{'chunksize'}\NormalTok{:}\DecValTok{10000}\NormalTok{\}}
              
\NormalTok{    T_init }\OperatorTok{=} \FloatTok{23.54}
\NormalTok{    LC_init }\OperatorTok{=}\NormalTok{ np.array([.}\DecValTok{1734}\NormalTok{,.}\DecValTok{39}\NormalTok{,}\FloatTok{1.8814}\NormalTok{,.}\DecValTok{2708}\NormalTok{,T_init])}
    
\NormalTok{    a }\OperatorTok{=}\NormalTok{ StrongCoupling(rhs,coupling,LC_init,var_names,pardict,}\OperatorTok{**}\NormalTok{kwargs)}
\end{Highlighting}
\end{Shaded}

Please see the StrongCoupling class below for more details on these
keyword arguments. It is not necessary to define the kwargs dict as
shown above -- keyword arguments may be entered in the standard
keyword=value format straight into the StrongCoupling class.

Assuming that the appropriate libraries have been installed, you should
be able to run this script now:

\begin{verbatim}
$ python3 goodwin.py
\end{verbatim}

When the program runs, it will attempt to find the limit cycle. The
limit cycle initial condition must be estimated by hand. For example, I
used XPP and simulated the limit cycle for a long time, then extracted
x, y, z, v values at some large time value. The XPP file for this
oscillator is contained in ode/goodwin.ode. The initial condition and
period do not need to be precise because the code will search for the
limit cycle via Newton's method, but closer is better.

\subsubsection{Computing Floquet Eigenfunctions, PRCs, and
IRCs}\label{computing-floquet-eigenfunctions-prcs-and-ircs}

It will then solve for the one Floquet multiplier (assuming there is
only one slowest decaying mode) and turn to computing the hierarchy of
ODEs \(g^{(k)}\), \(z^{(k)}\), and \(i^{(k)}\) in that order. To solve
for the hierarchy, the parameters

\begin{verbatim}
g_forward, z_forward, i_forward
\end{verbatim}

tell the ODE solver to solve in forwards or backward time. With the
options above, the integrator will solve for \(g^{(k)}\) forwards in
time for all \(k\) and solve for \(z^{(k)}\) and \(i^{(k)}\) backwards
in time for all \(k\). These choices must be determined by hand, by
checking whether or not the Newton's method converges. It is an involved
process.

The parameter

\begin{verbatim}
i_bad_dx
\end{verbatim}

makes Newton's method include an additional variable when convergence is
weak. This parameter depends on the system. This is also an involved
process and can only be decided after attempting to solve the ODEs. I
will add more on this another time.

The parameters

\begin{verbatim}
rtol, atol, TN, method, dense, rel_tol
\end{verbatim}

are additional numerical parameters, most of which go into solve\_ivp.
rtol and atol determine the absolute and relative tolerance. I like to
keep these values small. TN is the total number of time steps to be used
in the 1d interpolation calls. dense is the keyword argument that goes
into solve\_ivp and determines whether the solver will use a predefined
time mesh or a time mesh determined by solve\_ivp. rel\_tol is the
convergence threshold for Newton's method.

It will take some time for the script to solve the symbolic equations
for \(g^{(k)}\), \(z^{(k)}\), and \(i^{(k)}\) then it will take a longer
time for the method to evaluate them numerically. rtol and atol
determine the speed of the numerical integration, and they may be
increased to speed up the integration depending on the system and the
desired order of \(\mathcal{H}\). Problems that do not need fine time
steps to solve for \(g^{(k)}\), \(z^{(k)}\), and \(i^{(k)}\) can afford
to use larger rtol and atol.

As the script generates \(g^{(k)}\), \(z^{(k)}\), and \(i^{(k)}\)
functions, it will save plots to the current working directory
(plot*.png). These plots are for debugging purposes, so that the user
can check whether or not functions are converging and decide if the
numerical choice above are appropriate. If you wish to save these plots,
please rename or copy/paste them to another directory. The
StrongCoupling will overwite the plots when any example is run.

The symbolic files and data files for \(g^{(k)}\), \(z^{(k)}\), and
\(i^{(k)}\) are saved to

\begin{verbatim}
home+goodwin_dat/
\end{verbatim}

File names

\begin{verbatim}
*_data*_TN_*.txt 
\end{verbatim}

Contain the trajectories for \(g^{(k)}\), \(z^{(k)}\), and \(i^{(k)}\).
Symbolic functions are saved to

\begin{verbatim}
*.d
\end{verbatim}

files.

\subsubsection{Computing Generalized Interaction
Functions}\label{computing-generalized-interaction-functions}

The parameters

\begin{verbatim}
processes, chunksize
\end{verbatim}

set the number of processors to use for multiprocessing and the number
of `jobs' to give to each processor when computing \(p^{(k)}\). There is
no hard and fast rule for these values. Please see the other example
files to get an idea for how chunksize can be set.

The script will then generate the symbolic coupling functions and
evaluate them to generate the \(p^{(k)}\) functions using the 4 cores
specified earlier, then generate the \(\mathcal{H}^{(k)}\) functions up
to 5th order. The data for the \(\mathcal{H}^{(k)}\) functions will be
saved to

\begin{verbatim}
home+goodwin_dat/
\end{verbatim}

i.e., the goodwin\_dat folder in the home directory, with the file names

\begin{verbatim}
h_dat_*_NA=2000_piter=20.txt
\end{verbatim}

\subsection{Plotting Data}\label{plotting-data}

It is up to you to decide how to use these files. To plot the files,
feel free to append the following lines to the main() function:

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{# plot H functions}
\NormalTok{    phi }\OperatorTok{=}\NormalTok{ np.linspace(}\DecValTok{0}\NormalTok{,a.T,a.NA)}
    \ControlFlowTok{for}\NormalTok{ k }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(a.trunc_order}\OperatorTok{+}\DecValTok{1}\NormalTok{):}
\NormalTok{        fig }\OperatorTok{=}\NormalTok{ plt.figure()}
\NormalTok{        ax }\OperatorTok{=}\NormalTok{ fig.add_subplot(}\DecValTok{111}\NormalTok{)}
\NormalTok{        ax.plot(phi,a.hodd[}\StringTok{'dat'}\NormalTok{][k])}
\NormalTok{        ax.set_title(}\StringTok{'hodd'}\OperatorTok{+}\BuiltInTok{str}\NormalTok{(k)}\OperatorTok{+}\StringTok{' NA='}\OperatorTok{+}\BuiltInTok{str}\NormalTok{(a.NA))}
\NormalTok{        plt.show(block}\OperatorTok{=}\VariableTok{True}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\section{\texorpdfstring{Module
\texttt{StrongCoupling}}{Module StrongCoupling}}\label{StrongCoupling}

StrongCoupling.py computes the higher-order interaction functions from
Park and Wilson 2020 for \(N=2\) models and one Floquet multiplier. In
broad strokes, this library computes functions in the following order:

\begin{itemize}
\tightlist
\item
  Use the equation for \(\Delta x\) (15) to produce a hierarchy of ODEs
  for \(g^{(k)}\) and solve. (Wilson 2020)
\item
  Do the same using (30) and (40) to generate a hierarchy of ODEs for
  \(Z^{(k)}\) and \(I^{(k)}\), respectively. (Wilson 2020)
\item
  Solve for \(\phi\) in terms of \(\theta_i\), (13), (14) (Park and
  Wilson 2020)
\item
  Compute the higher-order interaction functions (15) (Park and Wilson
  2020)
\end{itemize}

Notes: - pA requires endpoint=False. make sure corresponding dxAs are
used.

\subsection{Functions}\label{functions}

\subsubsection{\texorpdfstring{Function
\texttt{module\_exists}}{Function module\_exists}}\label{StrongCoupling.module_exists}

\begin{quote}
\begin{verbatim}
def module_exists(
    module_name
)
\end{verbatim}
\end{quote}

\subsection{Classes}\label{classes}

\subsubsection{\texorpdfstring{Class
\texttt{StrongCoupling}}{Class StrongCoupling}}\label{StrongCoupling.StrongCoupling}

\begin{quote}
\begin{verbatim}
class StrongCoupling(
    rhs,
    coupling,
    LC_init,
    var_names,
    pardict,
    **kwargs
)
\end{verbatim}
\end{quote}

See the defaults dict below for allowed kwargs.

All model parameters must follow the convention `parameter\_val'. No
other underscores should be used. the script splits the parameter name
at '\_' and uses the string to the left as the sympy parmeter name.

Reserved names: \ldots{}

\begin{verbatim}
rhs: callable.
    right-hand side of a model
coupling: callable.
    coupling function between oscillators
LC_init: list or numpy array.
    initial condition of limit cycle (must be found manually).
    XPP is useful, otherwise integrate your RHS for various
    initial conditions for long times and extract an initial
    condition close to the limit cycle.
var_names: list.
    list of variable names as strings
pardict: dict.
    dictionary of parameter values. dict['par1_val'] = float.
    Make sure to use par_val format, where each parameter name is
    followed by _val.
recompute_LC: bool.
    If True, recompute limit cycle. If false, load limit cycle if
    limit cycle data exists. Otherwise, compute. Default: False.
recompute_monodromy: bool.
    If true, recompute kappa, the FLoquet multiplier using the
    monodromy matrix. If false, load kappa if data exists,
    otherwise compute. Default: False.
recompute_g_sym: bool.
    If true, recompute the symbolic equations for g^k. If false,
    load the symbolic equations if they exist in storage.
    Otherwise, compute. Default: False.
recompute_g: bool.
    If true, recompute the ODEs for g^k. If false,
    load the data for g^k if they exist in storage.
    Otherwise, compute. Default: False.
recompute_het_sym: bool.
    If true, recompute the symbolic equations for z^k and i^k.
    If false, load the symbolic equations if they exist in
    storage. Otherwise, compute. Default: False.
recompute_z: bool.
    If true, recompute the ODEs for z^k. If false,
    load the data for z^k if they exist in storage.
    Otherwise, compute. Default: False.
recompute_i: bool.
    If true, recompute the ODEs for i^k. If false,
    load the data for i^k if they exist in storage.
    Otherwise, compute. Default: False.
recompute_k_sym: bool.
    If true, recompute the symbolic equations for K^k. If false,
    load the symbolic equations if they exist in storage.
    Otherwise, compute. Default: False.
recompute_p_sym: bool.
    If true, recompute the symbolic equations for p^k. If false,
    load the symbolic equations if they exist in storage.
    Otherwise, compute. Default: False.
recompute_k_sym: bool.
    If true, recompute the symbolic equations for H^k. If false,
    load the symbolic equations if they exist in storage.
    Otherwise, compute. Default: False.
recompute_h: bool.
    If true, recompute the H functions for H^k. If false,
    load the data equations if they exist in storage.
    Otherwise, compute. Default: False.
g_forward: list or bool.
    If bool, integrate forwards or backwards
    when computing g^k. If list, integrate g^k forwards or
    backwards based on bool value g_forward[k].
    Default: False.
z_forward: list or bool.
    Same idea as g_forward for PRCS. Default: False.
i_forward: list or bool.
    Same idea as g_forward for IRCS. Default: False.
dense: bool.
    If True, solve_ivp uses dense=True and evaluate solution
    along tLC.
dir: str.
    Location of data directory. Please choose carefully
    because some outputs may be on the order of gigabytes
    if NA >= 5000. Write 'home+data_dir/' to save to the folder
    'data_dir' in the home directory. Otherwise the script
    will use the current working directory by default uless
    an absolute path is used. The trailing '/' is
    required. Default: None.
trunc_order: int.
    Highest order to truncate the expansion. For example, 
    trunc_order = 3 means the code will compute up to and 
    including order 3. Default: 3.
NA: int.
    Number of partitions to discretize phase when computing p.
    Default: 500.
p_iter: int.
    Number of periods to integrate when computing the time 
    interal in p. Default: 10.
max_iter: int.
    Number of Newton iterations. Default: 20.
TN: int.
    Total time steps when computing g, z, i.
rtol, atol: float.
    Relative and absolute tolerance for ODE solvers.
    Defaults: 1e-7, 1e-7.
rel_tol: float.
    Threshold for use in Newton scheme. Default: 1e-6.
method: string.
    Specify the method used in scipy.integrate.solve_ivp.
    Default: LSODA.
g_bad_dx: list or bool. If bool, use another variable to increase
    the magnitude of the Newton derivative. This can only be
    determined after attempting to run simulations and seeing that
    the Jacobian for the Newton step is ill-conditioned. If list,
    check for ill-conditioning for each order k.
    For example, we use g_small_dx = [False,True,False,...,False]
    for the thalamic model. The CGL model only needs
    g_small_idx = False
z_Gbad_idx: same idea as g_small_idx for PRCs
i_bad_idx: same idea as g_small_idx for IRCs
\end{verbatim}

\paragraph{Methods}\label{methods}

\subparagraph{\texorpdfstring{Method
\texttt{bispeu}}{Method bispeu}}\label{StrongCoupling.StrongCoupling.bispeu}

\begin{quote}
\begin{verbatim}
def bispeu(
    self,
    fn,
    x,
    y
)
\end{verbatim}
\end{quote}

silly workaround \url{https://stackoverflow.com/questions/47087109/}
evaluate-the-output-from-scipy-2d-interpolation-along-a-curve

\subparagraph{\texorpdfstring{Method
\texttt{fLam2}}{Method fLam2}}\label{StrongCoupling.StrongCoupling.fLam2}

\begin{quote}
\begin{verbatim}
def fLam2(
    self,
    fn
)
\end{verbatim}
\end{quote}

interp2db object

\subparagraph{\texorpdfstring{Method
\texttt{fmod}}{Method fmod}}\label{StrongCoupling.StrongCoupling.fmod}

\begin{quote}
\begin{verbatim}
def fmod(
    self,
    fn
)
\end{verbatim}
\end{quote}

fn has mod built-in

input function-like. usually interp1d object

needed to keep lambda input variable unique to fn.

otherwise lambda will use the same input variable for all lambda
functions.

\subparagraph{\texorpdfstring{Method
\texttt{generate\_expansions}}{Method generate\_expansions}}\label{StrongCoupling.StrongCoupling.generate_expansions}

\begin{quote}
\begin{verbatim}
def generate_expansions(
    self
)
\end{verbatim}
\end{quote}

generate expansions from Wilson 2020

\subparagraph{\texorpdfstring{Method
\texttt{generate\_g}}{Method generate\_g}}\label{StrongCoupling.StrongCoupling.generate_g}

\begin{quote}
\begin{verbatim}
def generate_g(
    self,
    k,
    het_vec
)
\end{verbatim}
\end{quote}

generate Floquet eigenfunctions g

uses Newtons method

\subparagraph{\texorpdfstring{Method
\texttt{generate\_h\_odd}}{Method generate\_h\_odd}}\label{StrongCoupling.StrongCoupling.generate_h_odd}

\begin{quote}
\begin{verbatim}
def generate_h_odd(
    self,
    k
)
\end{verbatim}
\end{quote}

interaction functions

note to self: see nb page 130 for notes on indexing in sums. need to sum
over to index N-1 out of size N to avoid double counting boundaries in
mod operator.

\subparagraph{\texorpdfstring{Method
\texttt{generate\_het\_sym}}{Method generate\_het\_sym}}\label{StrongCoupling.StrongCoupling.generate_het_sym}

\begin{quote}
\begin{verbatim}
def generate_het_sym(
    self
)
\end{verbatim}
\end{quote}

Generate heterogeneous terms for integrating the Z\_i and I\_i terms.

Returns

None.

\subparagraph{\texorpdfstring{Method
\texttt{generate\_i}}{Method generate\_i}}\label{StrongCoupling.StrongCoupling.generate_i}

\begin{quote}
\begin{verbatim}
def generate_i(
    self,
    k,
    het_vec
)
\end{verbatim}
\end{quote}

i0 equation is stable in forwards time i1, i2, etc equations are stable
in backwards time.

\subparagraph{\texorpdfstring{Method
\texttt{generate\_k\_sym}}{Method generate\_k\_sym}}\label{StrongCoupling.StrongCoupling.generate_k_sym}

\begin{quote}
\begin{verbatim}
def generate_k_sym(
    self
)
\end{verbatim}
\end{quote}

\subparagraph{\texorpdfstring{Method
\texttt{generate\_limit\_cycle}}{Method generate\_limit\_cycle}}\label{StrongCoupling.StrongCoupling.generate_limit_cycle}

\begin{quote}
\begin{verbatim}
def generate_limit_cycle(
    self
)
\end{verbatim}
\end{quote}

\subparagraph{\texorpdfstring{Method
\texttt{generate\_p}}{Method generate\_p}}\label{StrongCoupling.StrongCoupling.generate_p}

\begin{quote}
\begin{verbatim}
def generate_p(
    self,
    k
)
\end{verbatim}
\end{quote}

\subparagraph{\texorpdfstring{Method
\texttt{generate\_p\_old}}{Method generate\_p\_old}}\label{StrongCoupling.StrongCoupling.generate_p_old}

\begin{quote}
\begin{verbatim}
def generate_p_old(
    self,
    k
)
\end{verbatim}
\end{quote}

\subparagraph{\texorpdfstring{Method
\texttt{generate\_z}}{Method generate\_z}}\label{StrongCoupling.StrongCoupling.generate_z}

\begin{quote}
\begin{verbatim}
def generate_z(
    self,
    k,
    het_vec
)
\end{verbatim}
\end{quote}

\subparagraph{\texorpdfstring{Method
\texttt{interp\_lam}}{Method interp\_lam}}\label{StrongCoupling.StrongCoupling.interp_lam}

\begin{quote}
\begin{verbatim}
def interp_lam(
    self,
    k,
    fn_dict,
    fn_type='z'
)
\end{verbatim}
\end{quote}

it is too slow to call individual interpolated functions in the symbolic
heterogeneous terms. soince the heterogeneous terms only depend on t,
just make and interpolated version and use that instead so only 1
function is called for the het. terms per iteration in numerical
iteration.

\subparagraph{\texorpdfstring{Method
\texttt{load\_g}}{Method load\_g}}\label{StrongCoupling.StrongCoupling.load_g}

\begin{quote}
\begin{verbatim}
def load_g(
    self
)
\end{verbatim}
\end{quote}

load all Floquet eigenfunctions g or recompute

\subparagraph{\texorpdfstring{Method
\texttt{load\_g\_sym}}{Method load\_g\_sym}}\label{StrongCoupling.StrongCoupling.load_g_sym}

\begin{quote}
\begin{verbatim}
def load_g_sym(
    self
)
\end{verbatim}
\end{quote}

\subparagraph{\texorpdfstring{Method
\texttt{load\_h}}{Method load\_h}}\label{StrongCoupling.StrongCoupling.load_h}

\begin{quote}
\begin{verbatim}
def load_h(
    self
)
\end{verbatim}
\end{quote}

\subparagraph{\texorpdfstring{Method
\texttt{load\_h\_sym}}{Method load\_h\_sym}}\label{StrongCoupling.StrongCoupling.load_h_sym}

\begin{quote}
\begin{verbatim}
def load_h_sym(
    self
)
\end{verbatim}
\end{quote}

also compute h lam

\subparagraph{\texorpdfstring{Method
\texttt{load\_het\_sym}}{Method load\_het\_sym}}\label{StrongCoupling.StrongCoupling.load_het_sym}

\begin{quote}
\begin{verbatim}
def load_het_sym(
    self
)
\end{verbatim}
\end{quote}

\subparagraph{\texorpdfstring{Method
\texttt{load\_i}}{Method load\_i}}\label{StrongCoupling.StrongCoupling.load_i}

\begin{quote}
\begin{verbatim}
def load_i(
    self
)
\end{verbatim}
\end{quote}

load all IRCs i or recomptue

\subparagraph{\texorpdfstring{Method
\texttt{load\_k\_sym}}{Method load\_k\_sym}}\label{StrongCoupling.StrongCoupling.load_k_sym}

\begin{quote}
\begin{verbatim}
def load_k_sym(
    self
)
\end{verbatim}
\end{quote}

kA, kB contain the ith order terms of expanding the coupling fun. cA, cB
contain the derivatives of the coupling fn.

\subparagraph{\texorpdfstring{Method
\texttt{load\_limit\_cycle}}{Method load\_limit\_cycle}}\label{StrongCoupling.StrongCoupling.load_limit_cycle}

\begin{quote}
\begin{verbatim}
def load_limit_cycle(
    self
)
\end{verbatim}
\end{quote}

\subparagraph{\texorpdfstring{Method
\texttt{load\_monodromy}}{Method load\_monodromy}}\label{StrongCoupling.StrongCoupling.load_monodromy}

\begin{quote}
\begin{verbatim}
def load_monodromy(
    self
)
\end{verbatim}
\end{quote}

if monodromy data exists, load. if DNE or recompute required, compute
here.

\subparagraph{\texorpdfstring{Method
\texttt{load\_p}}{Method load\_p}}\label{StrongCoupling.StrongCoupling.load_p}

\begin{quote}
\begin{verbatim}
def load_p(
    self
)
\end{verbatim}
\end{quote}

generate/load the ODEs for psi.

\subparagraph{\texorpdfstring{Method
\texttt{load\_p\_sym}}{Method load\_p\_sym}}\label{StrongCoupling.StrongCoupling.load_p_sym}

\begin{quote}
\begin{verbatim}
def load_p_sym(
    self
)
\end{verbatim}
\end{quote}

generate/load the het. terms for psi ODEs.

to be solved using integrating factor meothod.

pA{[}`sym'{]}{[}k{]} is the forcing function of order k

\subparagraph{\texorpdfstring{Method
\texttt{load\_z}}{Method load\_z}}\label{StrongCoupling.StrongCoupling.load_z}

\begin{quote}
\begin{verbatim}
def load_z(
    self
)
\end{verbatim}
\end{quote}

load all PRCs z or recompute

\subparagraph{\texorpdfstring{Method
\texttt{monodromy}}{Method monodromy}}\label{StrongCoupling.StrongCoupling.monodromy}

\begin{quote}
\begin{verbatim}
def monodromy(
    self,
    t,
    z
)
\end{verbatim}
\end{quote}

calculate right-hand side of system

\(\dot \Phi = J\Phi, \Phi(0)=I\),

where \(\Phi\) is a matrix solution

jacLC is the jacobian evaluated along the limit cycle

\subparagraph{\texorpdfstring{Method
\texttt{numerical\_jac}}{Method numerical\_jac}}\label{StrongCoupling.StrongCoupling.numerical_jac}

\begin{quote}
\begin{verbatim}
def numerical_jac(
    self,
    fn,
    x,
    eps=1e-07
)
\end{verbatim}
\end{quote}

return numerical Jacobian function

\section{\texorpdfstring{Module
\texttt{Thalamic}}{Module Thalamic}}\label{Thalamic}

Example: Thalamic model from Wilson and Ermentrout RSTA 2019, Rubin and
Terman JCNS 2004

\subsection{Functions}\label{functions-1}

\subsubsection{\texorpdfstring{Function
\texttt{coupling}}{Function coupling}}\label{Thalamic.coupling}

\begin{quote}
\begin{verbatim}
def coupling(
    vars_pair,
    pdict,
    option='val'
)
\end{verbatim}
\end{quote}

Synaptic coupling function between Thalamic oscillators.

E.g.,this Python function is the function \(G(x_i,x_j)\) in the equation
\(\frac{dx_i}{dt} = F(x_i) + \varepsilon G(x_i,x_j)\)

Parameters

\begin{verbatim}
vars_pair : list or array
    contains state variables from oscillator A and B, e.g.,
    vA, hA, rA, wA, vB, hB, rB, wB  
pdict : dict of flots or sympy objects.
    parameter dictionary pdict[key], val. key is always a string
    of the parameter. val is either the parameter value (float) or 
    the symbolic version of the parameter key.
option : string.
    Set to 'val' when inputs, t, z, pdict are floats. Set to
    'sym' when inputs t, z, pdict are sympy objects. The default
    is 'val'.
\end{verbatim}

Returns

\begin{verbatim}
numpy array or sympy Matrix
    returns numpy array if option == 'val'. 
    returns sympy Matrix if option == 'sym'
\end{verbatim}

\subsubsection{\texorpdfstring{Function
\texttt{main}}{Function main}}\label{Thalamic.main}

\begin{quote}
\begin{verbatim}
def main()
\end{verbatim}
\end{quote}

\subsubsection{\texorpdfstring{Function
\texttt{rhs}}{Function rhs}}\label{Thalamic.rhs}

\begin{quote}
\begin{verbatim}
def rhs(
    t,
    z,
    pdict,
    option='val'
)
\end{verbatim}
\end{quote}

Right-hand side of the Thalamic model from Wilson and Ermentrout RSTA
2019 and Rubin and Terman JCNS 2004

Parameters

\begin{verbatim}
t : float or sympy object.
    time
z : array or list of floats or sympy objects.
    state variables of the thalamic model v, h, r, w.
pdict : dict of flots or sympy objects.
    parameter dictionary pdict[key], val. key is always a string
    of the parameter. val is either the parameter value (float) or 
    the symbolic version of the parameter key.
option : string.
    Set to 'val' when inputs, t, z, pdict are floats. Set to
    'sym' when inputs t, z, pdict are sympy objects. The default
    is 'val'.
\end{verbatim}

Returns

\begin{verbatim}
numpy array or sympy Matrix
    returns numpy array if option == 'val'
    returns sympy Matrix if option == 'sym'
\end{verbatim}

\section{\texorpdfstring{Module \texttt{CGL}}{Module CGL}}\label{CGL}

Example: Complex Ginzburgh-Landau (CGL) model from Wilson and Ermentrout
RSTA 2019

\subsection{Functions}\label{functions-2}

\subsubsection{\texorpdfstring{Function
\texttt{coupling}}{Function coupling}}\label{CGL.coupling}

\begin{quote}
\begin{verbatim}
def coupling(
    vars_pair,
    pdict,
    option='value'
)
\end{verbatim}
\end{quote}

Diffusive coupling function between Complex Ginzburgh Landau (CGL)
oscillators.

E.g.,this Python function is the function \(G(x_i,x_j)\) in the equation
\(\frac{dx_i}{dt} = F(x_i) + \varepsilon G(x_i,x_j)\)

Parameters

\begin{verbatim}
vars_pair : list or array
    contains state variables from oscillator A and B, e.g.,
    x1,y1,x2,y2
pdict : dict of flots or sympy objects.
    parameter dictionary pdict[key], val. key is always a string
    of the parameter. val is either the parameter value (float) or 
    the symbolic version of the parameter key.
option : string.
    Set to 'val' when inputs, t, z, pdict are floats. Set to
    'sym' when inputs t, z, pdict are sympy objects. The default
    is 'val'.
\end{verbatim}

Returns

\begin{verbatim}
* numpy array or sympy Matrix
    * returns numpy array if option == 'val'. 
    returns sympy Matrix if option == 'sym'
\end{verbatim}

\subsubsection{\texorpdfstring{Function
\texttt{main}}{Function main}}\label{CGL.main}

\begin{quote}
\begin{verbatim}
def main()
\end{verbatim}
\end{quote}

\subsubsection{\texorpdfstring{Function
\texttt{rhs}}{Function rhs}}\label{CGL.rhs}

\begin{quote}
\begin{verbatim}
def rhs(
    t,
    z,
    pdict,
    option='value'
)
\end{verbatim}
\end{quote}

Right-hand side of the Complex Ginzburgh-Landau (CGL) model from Wilson
and Ermentrout RSTA 2019

Parameters

\begin{verbatim}
t : float or sympy object.
    time
z : array or list of floats or sympy objects.
    state variables of the thalamic model v, h, r, w.
pdict : dict of flots or sympy objects.
    parameter dictionary pdict[key], val. key is always a string
    of the parameter. val is either the parameter value (float) or 
    the symbolic version of the parameter key.
option : string.
    Set to 'val' when inputs, t, z, pdict are floats. Set to
    'sym' when inputs t, z, pdict are sympy objects. The default
    is 'val'.
\end{verbatim}

Returns

\begin{verbatim}
numpy array or sympy Matrix
    returns numpy array if option == 'val'
    returns sympy Matrix if option == 'sym'
\end{verbatim}

Generated by \emph{pdoc} 0.9.1 (\url{https://pdoc3.github.io}).

\end{document}
